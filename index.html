<!DOCTYPE html>
<html lang="en" class=""><head><script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script><script type="importmap">{
  "imports": {}
}</script></head><body>
<script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script>
<script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script>
<script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script>
<meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async="" imports":="" {}="" <meta="" name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script>


  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Dual Grid Cellular Automaton</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>



<canvas id="canvas"></canvas>

<script>
    // A global variable to store the microphone's volume
    var globalVolume = 0;
    var frameCounter = 0;
    let countingUp = true;
    function updateFrameCounter() {
      if (countingUp) {
        frameCounter++;
        if (frameCounter > 25) countingUp = false;
      } else {
        frameCounter--;
        if (frameCounter <= -12) countingUp = true;
      }
    }
  let smoothedVolume = 0;

function startMicPolling() {
  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 512; // smaller size = faster updates
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);

    const dataArray = new Uint8Array(analyser.frequencyBinCount);

    function updateVolume() {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
      let average = sum / dataArray.length;

      // Smooth with simple exponential moving average
      smoothedVolume = smoothedVolume * 0.8 + average * 0.2;

      globalVolume = 1 + smoothedVolume / 256; // normalize 0â€“1

      requestAnimationFrame(updateVolume);
    }
    updateVolume();
  }).catch(err => {
    console.error("Mic error:", err);
  });
}
startMicPolling();
    if ("AmbientLightSensor" in window) {
  const sensor = new AmbientLightSensor();
  sensor.addEventListener("reading", (event) => {
    console.log("Current light level:", sensor.illuminance);
  });
  sensor.addEventListener("error", (event) => {
    console.log(event.error.name, event.error.message);
  });
  sensor.start();

sensor.addEventListener("reading", (event) );
console.log(sensor.illuminsnce)
}

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const gridSize = 3;
    let rows, cols;

    // === Config ===
    const config = {
      gridA: {
        minNeighbors: 0 + globalVolume,
        maxNeighbors: 3,
        minOtherNeighbors: 0.2 - globalVolume,
        maxOtherNeighbors: 5 - globalVolume, 
        color: 'lime'
      },
      gridB: {
        minNeighbors: 0.1 * globalVolume,
        maxNeighbors: 1,
        minOtherNeighbors: 0 + globalVolume,
        maxOtherNeighbors: 2.5 - globalVolume,
        color: 'green'
      }
    };

    let gridA = [];
    let gridB = [];

    // === Init ===
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cols = Math.floor(canvas.width / gridSize);
      rows = Math.floor(canvas.height / gridSize);

      gridA = Array.from({ length: rows }, () => Array(cols).fill(0));
      gridB = Array.from({ length: rows }, () => Array(cols).fill(0));

      const midR = Math.floor(rows / 2);
      const midC = Math.floor(cols / 2);

      gridA[midR][midC] = 1;
      gridB[midR + 1][midC + 1] = 1;
    }

    function getWrapped(r, c) {
      return [(r + rows) % rows, (c + cols) % cols];
    }

    function countNeighbors(grid, r, c, mode = 'all') {
      let count = 0;
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : (mode === 'diagonal')
          ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
          : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (const [dr, dc] of directions) {
        const [nr, nc] = getWrapped(r + dr, c + dc);
        if (grid[nr][nc]) count++;
      }
      return count;
    }

    function updateGrid(fromGrid, mode, neighborRules, otherGrid) {
      const next = Array.from({ length: rows }, () => Array(cols).fill(0));
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : [[-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!fromGrid[r][c]) continue;

          const neighbors = countNeighbors(fromGrid, r, c);
          const otherNeighbors = countNeighbors(otherGrid, r, c);

          const withinSelf = neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors;
          const withinOther = otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors;

          if (!(withinSelf && withinOther)) continue;

          // Replicate
          for (const [dr, dc] of directions) {
            const [nr, nc] = getWrapped(r + dr, c + dc);
            // This is where we use the globalVolume to influence the outcome.
            // For example, if volume is high, cells are more likely to replicate.
            if (globalVolume + withinSelf - withinOther < 3) { 
                 next[nr][nc] = 1; 
            }
          }
        }
      }
      return next;
    }

    function drawGrid(grid, color) {
      ctx.fillStyle = color;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c]) {
            ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
          }
        }
      }
    }

    function step() {
   
      
      // Update Grid A and Grid B, now potentially influenced by globalVolume
      const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB);
      const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA);

      gridA = nextA;
      gridB = nextB;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid(gridA, config.gridA.color);
      drawGrid(gridB, config.gridB.color);

      requestAnimationFrame(step);
    }

    window.addEventListener("resize", resize);
    resize();
    step();

</script><script src="./script.js"></script></body></html>