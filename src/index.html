<!DOCTYPE html>
<html lang="en" class=""><head><script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script><script type="importmap">{
  "imports": {}
}</script></head><body>
<meta name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async="" imports":="" {}="" <meta="" name="title" content="Untitled Project"><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="./style.css"><script src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js" async=""></script>


  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Dual Grid Cellular Automaton</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>



<canvas id="canvas"></canvas>

<script>
    // A global variable to store the microphone's volume
    var globalVolume = 0.1;
    var frameCounter = 0;
    let countingUp = true;
    function updateFrameCounter() {
      if (countingUp) {
        frameCounter++;
        if (frameCounter > 25) countingUp = false;
      } else {
        frameCounter--;
        if (frameCounter <= 0) countingUp = true;
      }
    }
  
    async function startMicPolling() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);

        setInterval(() => {
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);

          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }    // Initial value from 'multiplier'
    
          globalVolume = sum+dataArray.length;
          
          // Debugging output: log the volume
          if (globalVolume > 0.1) {
            console.log(2);
          } else {
            console.log(1);
          }

        }, 490); // Poll once per second
      } catch (err) {
        console.error("Microphone permission denied or an error occurred: " + err);
      }
    }

    // Start the mic polling process
    startMicPolling();

    if ("AmbientLightSensor" in window) {
  const sensor = new AmbientLightSensor();
  sensor.addEventListener("reading", (event) => {
    console.log("Current light level:", sensor.illuminance);
  });
  sensor.addEventListener("error", (event) => {
    console.log(event.error.name, event.error.message);
  });
  sensor.start();

sensor.addEventListener("reading", (event) );
globalVolume = event;
}

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const gridSize = 4;
    let rows, cols;

    // === Config ===
    const config = {
      gridA: {
        minNeighbors: -1 + globalVolume,
        maxNeighbors: 3,
        minOtherNeighbors: 0 + globalVolume,
        maxOtherNeighbors: 5 / globalVolume, 
        color: 'lime'
      },
      gridB: {
        minNeighbors:  -1 + globalVolume,
        maxNeighbors: 1,
        minOtherNeighbors: 0 + globalVolume,
        maxOtherNeighbors: 2.5,
        color: 'green'
      }
    };

    let gridA = [];
    let gridB = [];

    // === Init ===
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cols = Math.floor(canvas.width / gridSize);
      rows = Math.floor(canvas.height / gridSize);

      gridA = Array.from({ length: rows }, () => Array(cols).fill(0));
      gridB = Array.from({ length: rows }, () => Array(cols).fill(0));

      const midR = Math.floor(rows / 2);
      const midC = Math.floor(cols / 2);

      gridA[midR][midC] = 1;
      gridB[midR + 1][midC + 1] = 1;
    }

    function getWrapped(r, c) {
      return [(r + rows) % rows, (c + cols) % cols];
    }

    function countNeighbors(grid, r, c, mode = 'all') {
      let count = 0;
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : (mode === 'diagonal')
          ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
          : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (const [dr, dc] of directions) {
        const [nr, nc] = getWrapped(r + dr, c + dc);
        if (grid[nr][nc]) count++;
      }
      return count;
    }

    function updateGrid(fromGrid, mode, neighborRules, otherGrid) {
      const next = Array.from({ length: rows }, () => Array(cols).fill(0));
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : [[-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!fromGrid[r][c]) continue;

          const neighbors = countNeighbors(fromGrid, r, c);
          const otherNeighbors = countNeighbors(otherGrid, r, c);

          const withinSelf = neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors;
          const withinOther = otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors;

          if (!(withinSelf && withinOther)) continue;

          // Replicate
          for (const [dr, dc] of directions) {
            const [nr, nc] = getWrapped(r + dr, c + dc);
            // This is where we use the globalVolume to influence the outcome.
            // For example, if volume is high, cells are more likely to replicate.
            if (globalVolume  > 0.1) { 
                 next[nr][nc] = 1; 
            }
          }
        }
      }
      return next;
    }

    function drawGrid(grid, color) {
      ctx.fillStyle = color;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c]) {
            ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
          }
        }
      }
    }

    function step() {
   
      
      // Update Grid A and Grid B, now potentially influenced by globalVolume
      const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB);
      const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA);

      gridA = nextA;
      gridB = nextB;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid(gridA, config.gridA.color);
      drawGrid(gridB, config.gridB.color);

      requestAnimationFrame(step);
    }

    window.addEventListener("resize", resize);
    resize();
    step();
</script>



<script src="./script.js"></script><script src="./script.js"></script><script src="./script.js"></script></body></html>