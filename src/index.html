<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Dual Grid Cellular Automaton</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
    // A global variable to store the microphone's volume
    let globalVolume = 0;

    // Mic polling function, now simplified
    async function startMicPolling() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);

        setInterval(() => {
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);

          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          globalVolume = sum+dataArray.length;
          
          // Debugging output: log the volume
          if (globalVolume > 1) {
            console.log(2);
          } else {
            console.log(1);
          }

        }, 100); // Poll once per second
      } catch (err) {
        console.error("Microphone permission denied or an error occurred: " + err);
      }
    }

    // Start the mic polling process
    startMicPolling();

    // Frame counter: counts 0 -> 100 then 100 -> 0 repeatedly
    let frameCounter = 2; // Initial value from 'multiplier'
    let countingUp = true;

    function updateFrameCounter() {
      if (countingUp) {
        frameCounter++;
        if (frameCounter >= 100) countingUp = false;
      } else {
        frameCounter--;
        if (frameCounter <= 0) countingUp = true;
      }
    }

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const gridSize = 4;
    let rows, cols;

    // === Config ===
    const config = {
      gridA: {
        minNeighbors: 0,
        maxNeighbors: 3,
        minOtherNeighbors: 0.5,
        maxOtherNeighbors: 4, 
        color: 'lime'
      },
      gridB: {
        minNeighbors: 0,
        maxNeighbors: 1,
        minOtherNeighbors: 0,
        maxOtherNeighbors: 2.5,
        color: 'green'
      }
    };

    let gridA = [];
    let gridB = [];

    // === Init ===
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cols = Math.floor(canvas.width / gridSize);
      rows = Math.floor(canvas.height / gridSize);

      gridA = Array.from({ length: rows }, () => Array(cols).fill(0));
      gridB = Array.from({ length: rows }, () => Array(cols).fill(0));

      const midR = Math.floor(rows / 2);
      const midC = Math.floor(cols / 2);

      gridA[midR][midC] = 1;
      gridB[midR + 1][midC + 1] = 1;
    }

    function getWrapped(r, c) {
      return [(r + rows) % rows, (c + cols) % cols];
    }

    function countNeighbors(grid, r, c, mode = 'all') {
      let count = 0;
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : (mode === 'diagonal')
          ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
          : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (const [dr, dc] of directions) {
        const [nr, nc] = getWrapped(r + dr, c + dc);
        if (grid[nr][nc]) count++;
      }
      return count;
    }

    function updateGrid(fromGrid, mode, neighborRules, otherGrid) {
      const next = Array.from({ length: rows }, () => Array(cols).fill(0));
      const directions = (mode === 'cardinal')
        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
        : [[-1, -1], [-1, 1], [1, -1], [1, 1]];

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!fromGrid[r][c]) continue;

          const neighbors = countNeighbors(fromGrid, r, c);
          const otherNeighbors = countNeighbors(otherGrid, r, c);

          const withinSelf = neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors;
          const withinOther = otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors;

          if (!(withinSelf && withinOther)) continue;

          // Replicate
          for (const [dr, dc] of directions) {
            const [nr, nc] = getWrapped(r + dr, c + dc);
            // This is where we use the globalVolume to influence the outcome.
            // For example, if volume is high, cells are more likely to replicate.
            if (globalVolume > -2) { 
                 next[nr][nc] = 1; 
            }
          }
        }
      }
      return next;
    }

    function drawGrid(grid, color) {
      ctx.fillStyle = color;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c]) {
            ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
          }
        }
      }
    }

    function step() {
      // updateFrameCounter(); - This was causing issues and isn't needed for mic logic
      
      // Update Grid A and Grid B, now potentially influenced by globalVolume
      const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB);
      const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA);

      gridA = nextA;
      gridB = nextB;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid(gridA, config.gridA.color);
      drawGrid(gridB, config.gridB.color);

      requestAnimationFrame(step);
    }

    window.addEventListener("resize", resize);
    resize();
    step();
</script>

</body>
</html>
