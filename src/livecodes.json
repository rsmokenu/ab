{
  "title": "Untitled Project",
  "description": "",
  "head": "<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />",
  "htmlAttrs": "lang=\"en\" class=\"\"",
  "tags": [],
  "activeEditor": "markup",
  "markup": {
    "language": "html",
    "content": "<!DOCTYPE html>\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">\n    <title>Dual Grid Cellular Automaton</title>\n    <style>\n        body { margin: 0; background: black; overflow: hidden; }\n        canvas { display: block; }\n    </style>\n</head>\n<body>\n\n<canvas id=\"canvas\"></canvas>\n\n<script>\n    // Global variable to store mic volume, accessible by all scripts\n    let averageVolume = 0;\n\n    // Define your constant here so it's globally accessible\n    const multiplier = 2;\n\n    // Function to get mic permission and start polling\n    async function startMicPolling() {\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n            console.log(\"Microphone access granted.\");\n\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const analyser = audioContext.createAnalyser();\n            const source = audioContext.createMediaStreamSource(stream);\n            source.connect(analyser);\n\n            setInterval(() => {\n                const dataArray = new Uint8Array(analyser.frequencyBinCount);\n                analyser.getByteFrequencyData(dataArray);\n\n                let sum = 0;\n                for (let i = 0; i < dataArray.length; i++) {\n                    sum += dataArray[i];\n                }\n                \n                // Update the global averageVolume variable\n                averageVolume = sum / dataArray.length;\n                \n                if (averageVolume > 0) {\n                    console.log(2); // Mic is picking up sound\n                } else {\n                    console.log(1); // Mic is silent\n                }\n\n            }, 1000); // Poll once per second\n        } catch (err) {\n            console.error(\"Microphone permission denied or an error occurred: \" + err);\n        }\n    }\n\n    // Call the function to start the mic polling process\n    startMicPolling();\n\n    // Frame counter: counts 0 -> 100 then 100 -> 0 repeatedly\n    let frameCounter = multiplier;\n    let countingUp = true;\n\n    function updateFrameCounter() {\n        if (countingUp) {\n            frameCounter++;\n            if (frameCounter >= 100) countingUp = false;\n        } else {\n            frameCounter--;\n            if (frameCounter <= 0) countingUp = true;\n        }\n    }\n\n    const canvas = document.getElementById(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    const gridSize = 4;\n    let rows, cols;\n\n    // === Config ===\n    const config = {\n        gridA: {\n            minNeighbors: 0,\n            maxNeighbors: 3,\n            minOtherNeighbors: 0.5,\n            maxOtherNeighbors: 4,\n            color: 'lime'\n        },\n        gridB: {\n            minNeighbors: 0,\n            maxNeighbors: 1,\n            minOtherNeighbors: 0,\n            maxOtherNeighbors: 2.5,\n            color: 'green'\n        }\n    };\n\n    let gridA = [];\n    let gridB = [];\n\n    // === Init ===\n    function resize() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        cols = Math.floor(canvas.width / gridSize);\n        rows = Math.floor(canvas.height / gridSize);\n\n        gridA = Array.from({ length: rows }, () => Array(cols).fill(0));\n        gridB = Array.from({ length: rows }, () => Array(cols).fill(0));\n\n        const midR = Math.floor(rows / 2);\n        const midC = Math.floor(cols / 2);\n\n        gridA[midR][midC] = 1;\n        gridB[midR + 1][midC + 1] = 1;\n    }\n\n    function getWrapped(r, c) {\n        return [(r + rows) % rows, (c + cols) % cols];\n    }\n\n    function countNeighbors(grid, r, c, mode = 'all') {\n        let count = 0;\n        const directions = (mode === 'cardinal')\n            ? [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            : (mode === 'diagonal')\n                ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n                : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];\n\n        for (const [dr, dc] of directions) {\n            const [nr, nc] = getWrapped(r + dr, c + dc);\n            if (grid[nr][nc]) count++;\n        }\n        return count;\n    }\n\n    function updateGrid(fromGrid, mode, neighborRules, otherGrid) {\n        const next = Array.from({ length: rows }, () => Array(cols).fill(0));\n        \n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < cols; c++) {\n                // If a cell is alive, it stays alive if it meets the rules\n                if (fromGrid[r][c] === 1) {\n                    const neighbors = countNeighbors(fromGrid, r, c);\n                    const otherNeighbors = countNeighbors(otherGrid, r, c);\n                    if (neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors &&\n                        otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors) {\n                        next[r][c] = 1;\n                    }\n                } else { // If a cell is dead, it can become alive\n                    const neighbors = countNeighbors(fromGrid, r, c);\n                    const otherNeighbors = countNeighbors(otherGrid, r, c);\n                    \n                    // The rule to become alive can be influenced by mic volume\n                    if (neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors &&\n                        otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors &&\n                        averageVolume > 10) { // Example: a cell becomes alive only if there's sound\n                        next[r][c] = 1;\n                    }\n                }\n            }\n        }\n        return next;\n    }\n\n    function drawGrid(grid, color) {\n        ctx.fillStyle = color;\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < cols; c++) {\n                if (grid[r][c]) {\n                    ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);\n                }\n            }\n        }\n    }\n\n    function step() {\n        // Update A based on A and B\n        const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB);\n\n        // Update B based on B and A\n        const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA);\n\n        gridA = nextA;\n        gridB = nextB;\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawGrid(gridA, config.gridA.color);\n        drawGrid(gridB, config.gridB.color);\n\n        requestAnimationFrame(step);\n    }\n\n    window.addEventListener(\"resize\", resize);\n    resize();\n    step();\n</script>\n\n</body>\n</html>\n"
  },
  "style": {
    "language": "css",
    "content": ""
  },
  "script": {
    "language": "javascript",
    "content": "  gridB = nextB;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawGrid(gridA, config.gridA.color);\n  drawGrid(gridB, config.gridB.color);\n\n  requestAnimationFrame(step);\n}\n\nwindow.addEventListener(\"resize\", resize);\nresize();\nstep();\n</script>\n\n</body></html>"
  },
  "stylesheets": [],
  "scripts": [],
  "cssPreset": "",
  "processors": [],
  "customSettings": {},
  "imports": {},
  "types": {},
  "tests": {
    "language": "typescript",
    "content": ""
  },
  "version": "46"
}