{
  "title": "Untitled Project",
  "description": "",
  "head": "<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />",
  "htmlAttrs": "lang=\"en\" class=\"\"",
  "tags": [],
  "activeEditor": "markup",
  "markup": {
    "language": "html",
    "content": "<!DOCTYPE html>\n<html lang=\"en\" class=\"\"><head><script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name=\"title\" content=\"Untitled Project\"><meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" href=\"./style.css\"><script src=\"https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js\" async=\"\"></script><script type=\"importmap\">{\n  \"imports\": {} \n} \n</script></head><body>\n<script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name=\"title\" content=\"Untitled Project\"><meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" href=\"./style.css\"><script src=\"https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js\" async=\"\"></script>\n<script>window.livecodes = window.livecodes || {};</script><title>Untitled Project</title><meta name=\"title\" content=\"Untitled Project\"><meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" href=\"./style.css\"><script src=\"https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js\" async=\"\"></script>\n<meta name=\"title\" content=\"Untitled Project\"><meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" href=\"./style.css\"><script src=\"https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js\" async=\"\" imports\":=\"\" {}=\"\" <meta=\"\" name=\"title\" content=\"Untitled Project\"><meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"stylesheet\" href=\"./style.css\"><script src=\"https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.js\" async=\"\"></script>\n\n\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">\n  <title>Dual Grid Cellular Automaton</title>\n  <style>\n    body { margin: 0; background: black; overflow: hidden; }\n    canvas { display: block; }\n  </style>\n\n\n\n<canvas id=\"canvas\"></canvas>\n\n<script>\n    // A global variable to store the microphone's volume\n    var globalVolume = 0;\n    var frameCounter = 0;\n    let countingUp = true;\n    function updateFrameCounter() {\n      if (countingUp) {\n        frameCounter++;\n        if (frameCounter > 25) countingUp = false;\n      } else {\n        frameCounter--;\n        if (frameCounter <= -12) countingUp = true;\n      }\n    }\n  let smoothedVolume = 0;\n\nfunction startMicPolling() {\n  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const analyser = audioContext.createAnalyser();\n    analyser.fftSize = 1024; // smaller size = faster updates\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n\n    function updateVolume() {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];\n      let average = sum / dataArray.length;\n\n      // Smooth with simple exponential moving average\n      smoothedVolume = smoothedVolume * 0.8 + average * 0.2;\n\n      globalVolume = 1 + smoothedVolume / 256; // normalize 0â€“1\n\n      requestAnimationFrame(updateVolume);\n    }\n    updateVolume();\n  }).catch(err => {\n    console.error(\"Mic error:\", err);\n  });\n}\nstartMicPolling();\n    if (\"AmbientLightSensor\" in window) {\n  const sensor = new AmbientLightSensor();\n  sensor.addEventListener(\"reading\", (event) => {\n    console.log(\"Current light level:\", sensor.illuminance);\n  });\n  sensor.addEventListener(\"error\", (event) => {\n    console.log(event.error.name, event.error.message);\n  });\n  sensor.start();\n\nsensor.addEventListener(\"reading\", (event) );\nconsole.log(sensor.illuminsnce)\n}\n\n    const canvas = document.getElementById(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    const gridSize = 7;\n    let rows, cols;\n\n    // === Config ===\n    const config = {\n      gridA: {\n        minNeighbors: 0 + globalVolume,\n        maxNeighbors: 3,\n        minOtherNeighbors: 0.2 - globalVolume,\n        maxOtherNeighbors: 5 - globalVolume, \n        color: 'lime'\n      },\n      gridB: {\n        minNeighbors: 0.1 * globalVolume,\n        maxNeighbors: 1 + globalVolume,\n        minOtherNeighbors: 0.1 * globalVolume,\n        maxOtherNeighbors: 2.5 - globalVolume,\n        color: 'green'\n      }\n    };\n\n    let gridA = [];\n    let gridB = [];\n\n    // === Init ===\n    function resize() {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      cols = Math.floor(canvas.width / gridSize);\n      rows = Math.floor(canvas.height / gridSize);\n\n      gridA = Array.from({ length: rows }, () => Array(cols).fill(0));\n      gridB = Array.from({ length: rows }, () => Array(cols).fill(0));\n\n      const midR = Math.floor(rows / 2);\n      const midC = Math.floor(cols / 2);\n\n      gridA[midR][midC] = 1;\n      gridB[midR + 1][midC + 1] = 1;\n    }\n\n    function getWrapped(r, c) {\n      return [(r + rows) % rows, (c + cols) % cols];\n    }\n\n    function countNeighbors(grid, r, c, mode = 'all') {\n      let count = 0;\n      const directions = (mode === 'cardinal')\n        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        : (mode === 'diagonal')\n          ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]\n          : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];\n\n      for (const [dr, dc] of directions) {\n        const [nr, nc] = getWrapped(r + dr, c + dc);\n        if (grid[nr][nc]) count++;\n      }\n      return count;\n    }\n\n    function updateGrid(fromGrid, mode, neighborRules, otherGrid) {\n      const next = Array.from({ length: rows }, () => Array(cols).fill(0));\n      const directions = (mode === 'cardinal')\n        ? [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        : [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          if (!fromGrid[r][c]) continue;\n\n          const neighbors = countNeighbors(fromGrid, r, c);\n          const otherNeighbors = countNeighbors(otherGrid, r, c);\n\n          const withinSelf = neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors;\n          const withinOther = otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors;\n\n          if (!(withinSelf && withinOther)) continue;\n\n          // Replicate\n          for (const [dr, dc] of directions) {\n            const [nr, nc] = getWrapped(r + dr, c + dc);\n            // This is where we use the globalVolume to influence the outcome.\n            // For example, if volume is high, cells are more likely to replicate.\n            if (globalVolume < 3) { \n                 next[nr][nc] = 1; \n            }\n          }\n        }\n      }\n      return next;\n    }\n\n    function drawGrid(grid, color) {\n      ctx.fillStyle = color;\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          if (grid[r][c]) {\n            ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);\n          }\n        }\n      }\n    }\n\n    function step() {\n   \n      \n      // Update Grid A and Grid B, now potentially influenced by globalVolume\n      const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB);\n      const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA);\n\n      gridA = nextA;\n      gridB = nextB;\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      drawGrid(gridA, config.gridA.color);\n      drawGrid(gridB, config.gridB.color);\n\n      requestAnimationFrame(step);\n    }\n\n    window.addEventListener(\"resize\", resize);\n    resize();\n    step();\n\n</script></body></html>"
  },
  "style": {
    "language": "css",
    "content": ""
  },
  "script": {
    "language": "javascript",
    "content": ""
  },
  "stylesheets": [],
  "scripts": [],
  "cssPreset": "",
  "processors": [],
  "customSettings": {},
  "imports": {},
  "types": {},
  "tests": {
    "language": "typescript",
    "content": ""
  },
  "version": "46"
}