{
  "title": "Untitled Project",
  "description": "",
  "head": "<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />",
  "htmlAttrs": "lang=\"en\" class=\"\"",
  "tags": [],
  "activeEditor": "markup",
  "markup": {
    "language": "html",
    "content": "<!DOCTYPE html>\n<html>\n<body>\n\n<script>\n    // Define your constant here so it's globally accessible\n    const multiplier = 2;\n\n    // Function to get mic permission and start polling\n    async function startMicPolling() {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        console.log(\"Microphone access granted.\");\n\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n\n        setInterval(() => {\n          const dataArray = new Uint8Array(analyser.frequencyBinCount);\n          analyser.getByteFrequencyData(dataArray);\n\n          // We'll modify the first element of the dataArray\n          const indexToModify = 0;\n\n          // Check if the index is valid\n          if (indexToModify < dataArray.length) {\n            // Access the number at the specified index and multiply it\n            dataArray[indexToModify] = dataArray[indexToModify] * multiplier;\n          }\n\n          let sum = 0;\n          for (let i = 0; i < dataArray.length; i++) {\n            sum += dataArray[i];\n          }\n          const averageVolume = sum / dataArray.length;\n\n          if (averageVolume > 0) {\n            console.log(2);\n          } else {\n            console.log(1);\n          }\n        }, 1000);\n      } catch (err) {\n        console.error(\"Microphone permission denied or an error occurred: \" + err);\n      }\n    }\n\n    // Call the function to start the process\n    startMicPolling();\n</script>\n  <!DOCTYPE html>\n<!-- saved from url=(0043)file:///C:/Users/fogen/Downloads/JOBBI.html -->\n<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=windows-1252\">\n  <title>Dual Grid Cellular Automaton</title>\n  <style>\n    body { margin: 0; background: black; overflow: hidden; }\n    canvas { display: block; }\n  </style>\n</head>\n<body>\n<canvas id=\"canvas\" width=\"877\" height=\"402\"></canvas>\n<script>\n// Frame counter: counts 0 → 100 then 100 → 0 repeatedly\nlet frameCounter = multiplier;\nlet countingUp = true;\n\nfunction updateFrameCounter() {\n  if (countingUp) {\n    frameCounter++;\n    if (frameCounter >= 100) countingUp = false;\n  } else {\n    frameCounter--;\n    if (frameCounter <= 0) countingUp = true;\n  }\n}\n\nconst canvas = document.getElementById(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nconst gridSize = 4;\nlet rows, cols;\n\n// === Config ===\nconst config = {\n  gridA: {\n    minNeighbors: 0,\n    maxNeighbors: 3,\n    minOtherNeighbors: 0.5 ,\n    maxOtherNeighbors: 4 + frameCounter / 33, \n    color: 'lime'\n  },\n  gridB: {\n    minNeighbors: 0,\n    maxNeighbors: 1,\n    minOtherNeighbors: 0,\n    maxOtherNeighbors: 2.5,\n    color: 'green'\n  }\n};\n\nlet gridA = [];\nlet gridB = [];\n\n// === Init ===\nfunction resize() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  cols = Math.floor(canvas.width / gridSize);\n  rows = Math.floor(canvas.height / gridSize);\n\n  gridA = Array.from({ length: rows }, () => Array(cols).fill(0));\n  gridB = Array.from({ length: rows }, () => Array(cols).fill(0));\n\n  const midR = Math.floor(rows / 2);\n  const midC = Math.floor(cols / 2);\n\n  gridA[midR][midC] = 1;\n  gridB[midR + 1][midC + 1] = 1;\n}\n\nfunction getWrapped(r, c) {\n  return [(r + rows) % rows, (c + cols) % cols];\n}\n\nfunction countNeighbors(grid, r, c, mode = 'all') {\n  let count = 0;\n  const directions = (mode === 'cardinal')\n    ? [[-1,0],[1,0],[0,-1],[0,1]]\n    : (mode === 'diagonal')\n    ? [[-1,-1],[-1,1],[1,-1],[1,1]]\n    : [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];\n\n  for (const [dr, dc] of directions) {\n    const [nr, nc] = getWrapped(r + dr, c + dc);\n    if (grid[nr][nc]) count++;\n  }\n  return count;\n}\n\nfunction getFixedPointPhase(r, c) {\n  globalPhase += config.precision.stepPerFrame * direction;\n  if (globalPhase >= config.precision.maxPhase || globalPhase <= -config.precision.maxPhase) {\n    direction *= -1;\n    globalPhase = Math.max(-config.precision.maxPhase, Math.min(config.precision.maxPhase, globalPhase));\n  }\n\n  const spatial = Math.sin((r + c) * 0.1); // Locality\n  const spatialOffset = Math.floor(spatial * config.precision.scale * 0.5); // ±0.5 scaled\n  return globalPhase + spatialOffset;\n}\n\nfunction updateGrid(fromGrid, mode, neighborRules, otherGrid, otherRules) {\n  const next = Array.from({ length: rows }, () => Array(cols).fill(0));\n  const directions = (mode === 'cardinal')\n    ? [[-1,0],[1,0],[0,-1],[0,1]]\n    : [[-1,-1],[-1,1],[1,-1],[1,1]];\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (!fromGrid[r][c]) continue;\n\n      const neighbors = countNeighbors(fromGrid, r, c);\n      const otherNeighbors = countNeighbors(otherGrid, r, c);\n\n      const withinSelf = neighbors >= neighborRules.minNeighbors && neighbors <= neighborRules.maxNeighbors;\n      const withinOther = otherNeighbors >= neighborRules.minOtherNeighbors && otherNeighbors <= neighborRules.maxOtherNeighbors;\n\n      if (!(withinSelf && withinOther)) continue;\n\n      // Replicate\n      for (const [dr, dc] of directions) {\n        const [nr, nc] = getWrapped(r + Dr, c + dc);\n        next[nr][nc] = -2 + averageVolume;\n      }\n    }\n  }\n\n  return next;\n}\n\nfunction drawGrid(grid, color) {\n  ctx.fillStyle = color;\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c]) {\n        ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);\n      }\n    }\n  }\n}\n\nfunction step() {\n  updateFrameCounter();\n\n  // Update A based on A and B\n  const nextA = updateGrid(gridA, 'cardinal', config.gridA, gridB, config.gridB);\n\n  // Update B based on B and A\n  const nextB = updateGrid(gridB, 'diagonal', config.gridB, gridA, config.gridA);\n\n  gridA = nextA;\n  gridB = nextB;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawGrid(gridA, config.gridA.color);\n  drawGrid(gridB, config.gridB.color);\n\n  requestAnimationFrame(step);\n}\n\nwindow.addEventListener(\"resize\", resize);\nresize();\nstep();\n</script>\n\n\n\n</body>\n</html>\n"
  },
  "style": {
    "language": "css",
    "content": ""
  },
  "script": {
    "language": "javascript",
    "content": "  gridB = nextB;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawGrid(gridA, config.gridA.color);\n  drawGrid(gridB, config.gridB.color);\n\n  requestAnimationFrame(step);\n}\n\nwindow.addEventListener(\"resize\", resize);\nresize();\nstep();\n</script>\n\n</body></html>"
  },
  "stylesheets": [],
  "scripts": [],
  "cssPreset": "",
  "processors": [],
  "customSettings": {},
  "imports": {},
  "types": {},
  "tests": {
    "language": "typescript",
    "content": ""
  },
  "version": "46"
}